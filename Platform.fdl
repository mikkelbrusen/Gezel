$option "vcd"


////////////////////////////
// CPU
////////////////////////////

dp xor( in a, b : tc(32); 
    out r : ns(1)){
  always{
  r = (a != b);
  }
}

dp mux(
  in select :ns(1);
  in a, b :tc(32);  
  out r :tc(32))
{
  always{
    r = (select==0) ? a : b;
  }
}

dp muxalu  : mux
dp muxmem  : mux
dp muxstore : mux

dp alu(
  in a, b   :tc(32);
  in sel    :ns(2); 
  out r   :tc(32);
  out n :ns(1))
{
  always{
    r = (sel==1) ? a + b :
      (sel==2) ? a - b : 
      (sel==3) ? a>>5 :
             a;
    n = (r<0) ? 1 : 0;
  }
}

dp register(
  in asel, bsel, storesel : ns(3);
  in storeenable      : ns(1);  
  in storedata      : ns(32);
  out a,b         : tc(32)
){
  reg r0,r1,r2,r3,r4,r5,r6,r7 : tc(32);
  sig s4 : tc(32);
  always{
    s4 = r4;
    a = (asel==0) ? r0 : 
      (asel==1) ? r1 :
      (asel==2) ? r2 :
      (asel==3) ? r3 :
      (asel==4) ? r4 : 
      (asel==5) ? r5 :
      (asel==6) ? r6 : 
            r7;

    b = (bsel==0) ? r0 : 
      (bsel==1) ? r1 :
      (bsel==2) ? r2 :
      (bsel==3) ? r3 :
      (bsel==4) ? r4 : 
      (bsel==5) ? r5 :
      (bsel==6) ? r6 : 
            r7;

    r1 = (storeenable==1) ? (storesel==1) ? storedata : r1: r1 ;
    r2 = (storeenable==1) ? (storesel==2) ? storedata : r2: r2 ;
    r3 = (storeenable==1) ? (storesel==3) ? storedata : r3: r3 ;
    r4 = (storeenable==1) ? (storesel==4) ? storedata : r4: r4 ;
    r5 = (storeenable==1) ? (storesel==5) ? storedata : r5: r5 ;
    r6 = (storeenable==1) ? (storesel==6) ? storedata : r6: r6 ;
    r7 = (storeenable==1) ? (storesel==7) ? storedata : r7: r7 ;

    //$display($dec,"r7:", r7);  // New data pointer
    //$display($dec,"r2:",r2);  // Old data pointer
    //$display($dec,"r1:",r1);  // New data 
    //$display($dec,"r6:"r6);  // Old data
    //$display($dec,"r3:",r3);  // sum
    $display($dec,s4);  // Result inspection
  }

  $trace(r1, "traces/r1.seq");
  $trace(r2, "traces/r2.seq");
  $trace(r3, "traces/r3.seq");
  $trace(r4, "traces/r4.seq");
  $trace(r5, "traces/r5.seq");
  $trace(r6, "traces/r6.seq");
  $trace(r7, "traces/r7.seq");
}

dp signExtend( 
  in a  : tc(16);
  out r   : tc(32))
{
  sig d : ns(1);
  sig b : tc(32);
  sig c : tc(32);

  always{
    b = 0;
    c = 4294901760;
    d = a[15];
    r = (d == 0) ? a :
            a | c ; 
  }
}

ipblock instmem(in address  : ns(5);
        in wr,rd  : ns(1);
        in idata  : ns(32);
        out odata   : ns(32)){
  iptype "ram";
  ipparm "size=64";
  ipparm "wl=32";
  ipparm "file=program.txt";
}

dp control( in up         : ns(4);
      out regwrite, muxalus : ns(1);
      out alus       : ns(2);
      out bneg, branch   : ns(1);
      out mwr, mrd, muxmems, cops, muxss : ns(1))
{
  always{
    regwrite = ((up == 0b1010) | (up == 0b1001) | (up == 0b0001) | (up == 0b0010) | (up == 0b0100) | (up == 0b0110) | (up == 0b1000)) ? 1 : 0;
    muxalus = ((up == 0b0011) | (up == 0b1001) | (up == 0b0101) | (up == 0b0110) | (up == 0b0111)) ? 1 : 0;
    alus = (up == 0b0010 | up == 0b0110) ? 1 : (up == 0b0001) ? 2 : (up == 0b1000) ? 3 : 0;
    bneg = (up == 0b0101);
    branch = (up == 0b0111);
    mwr = (up == 0b0011);
    mrd = (up == 0b1001); 
    muxmems = (up == 0b1001) | (up == 0b1010);
    cops = (up == 0b1010);
    muxss = (up == 0b1010);
  }
}

dp and( in a,b  : ns(1); 
    out r   : ns(1))
{
  always{
    r = a & b;
  }
}

dp or(  in a,b : ns(1); 
    out r : ns(1))
{
  always{
    r = a | b;
  }
}

dp memor : or

dp PC(  in branch : ns(1);
    in target     : ns(5);
    in stall      : ns(1);
    out pc_out    : ns(5))
  {
  reg PCr : ns(5);

  always{
    pc_out = (branch) ? target : PCr + 1 - stall;
    PCr = pc_out;
  }
}

dp CPU(
           out M_datain : ns(32);
           out M_cmd : ns(32);
           out M_datainrdy : ns(1);
           in M_dataout : ns(32);
           in M_dataoutrdy : ns(1)
           //in stall_cpu : ns(1)
       ){
        sig pc_out      : ns(5);
        sig inst      : ns(32);
        sig regwrite    : ns(1);
        sig storedata     : ns(32);
        sig a, b, muxaluo : tc(32);
        sig alus      : ns(2);
        reg neg      : ns(1);
        sig alu_out     : tc(32);
        sig extendo     : tc(32);
        sig muxalus     : ns(1);
        sig jump, andout  : ns(1);
        sig branch, bneg : ns(1);
        sig mwr, mrd  : ns(1);
        sig stall, memoro, muxmems,cops : ns(1);
        sig muxmemo : ns(32);
        sig storeenable, muxss,outstore : ns(1);

        use PC(jump, extendo[0:4], stall, pc_out);
        use instmem(pc_out,0,1,0,inst);
        use control(inst[28:31],regwrite,muxalus,alus,bneg,branch,mwr,mrd,muxmems,cops,muxss);
        use register(inst[25:27],inst[22:24],inst[19:21],storeenable,muxmemo,a,b);
        use alu(a,muxaluo,alus,alu_out,neg);
        use signExtend(inst[0:15],extendo);
        use and(neg, bneg, andout);
        use or(andout, branch, jump);
        use muxalu(muxalus,b,extendo,muxaluo);
        use memor(cops,mrd,memoro);
        use xor(memoro,M_dataoutrdy,stall);
        use muxmem(muxmems,alu_out,M_dataout,muxmemo);
        use muxstore(muxss,regwrite,outstore,storeenable);

        $trace(alu_out, "traces/aluOut.seq");
        $trace(bneg, "traces/bneg.seq");
        $trace(branch, "traces/branch.seq");
        $trace(stall, "traces/stall.seq");
        $trace(neg, "traces/neg.seq");
        $trace(jump, "traces/jump.seq");
        $trace(M_dataoutrdy, "traces/rdy.seq");
        $trace(mwr, "traces/mwr.seq");
        $trace(mrd, "traces/mrd.seq");
        $trace(M_dataout, "traces/CPUM_dataout.seq");
        $trace(pc_out, "traces/pc_out.seq");
        $trace(cops, "traces/cops.seq");
        $trace(storeenable, "traces/storeenable.seq");

       always{
       		M_datain = b;
       		M_cmd =  (mwr == 1) ? ( 0x28000000 | alu_out) :
                   (mrd == 1) ? 0x20000000 : 
                   (cops == 1) ? 0x40000000 : 0;
       		M_datainrdy = mrd | mwr | cops;
          //$display($dec, "mrd:",mrd,", rdy: ", M_dataoutrdy, ", dout:", M_dataout, ", datain:", M_datain);
          //$display($dec, "cops:",cops,", rdy: ", M_dataoutrdy, ", dout:", M_dataout, ", datain:", M_datain,$bin, ", cmd:",M_cmd);
          //$display($dec,"pc:",pc_out);
          //$display($dec, "Cycle:",$cycle);
          outstore = (M_dataoutrdy & regwrite);
       }       
}

////////////////////////////
// Bus
////////////////////////////

dp bus(
        // CPU interface
        in reqCPU  : ns(1);
        in cmdCPU : ns(32); // What command should be executed at the unit receiving this + ID of destination unit is in 4 MSB
        in dataoutCPU : ns(32); // data from the CPU
        out ackCPU : ns(1); 
                
        out dataRdyCPU : ns(1); // high when unit has data, which is ready for the CPU
        out datainCPU : ns(32); // data to the CPU
        in waitCPU : ns(1); // Remains high until the CPU has read the data

        // Co-Processor interface
        out reqCoP : ns(1);
        out cmdCoP : ns(32);
        out datainCoP : ns(32); 
        in ackCoP : ns(1);

        in dataRdyCoP : ns(1);
        in dataoutCoP : ns(32);
        out waitCoP : ns(1);
                
        // Data Memory interface
        out reqDataMem : ns(1);
        out cmdDataMem : ns(32);
        out datainDataMem : ns(32); // data to Data memory from CPU
        in ackDataMem : ns(1);
               
        in dataRdyDataMem : ns(1); 
        in dataoutDataMem : ns(32); // data from Data memory to CPU
        out waitDataMem : ns(1);
        
        // Sensor interface
        out reqSensor : ns(1);
        out cmdSensor : ns(32); // only cmd is needed to the sensor
        out NotUsed1 : ns(32); // dataport not used
        in ackSensor : ns(1);
        
        in dataRdySensor : ns(1);
        in dataoutSensor : ns(32);
        out waitSensor : ns(1);
        
        // Output interface
        out reqOutput : ns(1);
        out cmdOutput : ns(32);
        out datainOutput : ns(32); // data to output from CPU
        in ackOutput : ns(1);
               
        in dataRdyOutput : ns(1); 
        in dataoutOutput : ns(32); // data from output to CPU
        out waitOutput : ns(1);
        
        // IDs
        in ID_Sensor : ns(4);
        in ID_DataMem : ns(4);
        in ID_Output : ns(4);
        in ID_CoP : ns(4)
		
        ){
        
        $trace(reqDataMem, "traces/reqDataMem.seq");
        $trace(cmdDataMem, "traces/cmdDataMem.seq");
        $trace(datainDataMem, "traces/datainDataMem.seq");
        $trace(ackDataMem, "traces/ackDataMem.seq");
        $trace(dataRdyDataMem, "traces/dataRdyDataMem.seq");
        $trace(dataoutDataMem, "traces/dataoutDataMem.seq");
        $trace(waitDataMem, "traces/waitDataMem.seq");
        
        $trace(reqSensor, "traces/reqSensor.seq");
        $trace(cmdSensor, "traces/cmdSensor.seq");
        $trace(ackSensor, "traces/ackSensor.seq");
        $trace(dataRdySensor, "traces/dataRdySensor.seq");
        $trace(dataoutSensor, "traces/dataoutSensor.seq");
        $trace(waitSensor, "traces/waitSensor.seq");
        
        $trace(reqOutput, "traces/reqOutput.seq");
        $trace(cmdOutput, "traces/cmdOutput.seq");
        $trace(datainOutput, "traces/datainOutput.seq");
        $trace(ackOutput, "traces/ackOutput.seq");
        $trace(dataRdyOutput, "traces/dataRdyOutput.seq");
        $trace(dataoutOutput, "traces/dataoutOutput.seq");
        $trace(waitOutput, "traces/waitOutput.seq");
        
        $trace(reqCPU, "traces/reqCPU.seq");
        $trace(cmdCPU, "traces/cmdCPU.seq");
        $trace(dataoutCPU, "traces/dataoutCPU.seq");
        $trace(ackCPU, "traces/ackCPU.seq");
        $trace(dataRdyCPU, "traces/dataRdyCPU.seq");
        $trace(datainCPU, "traces/datainCPU.seq");
        $trace(waitCPU, "traces/waitCPU.seq");
        
        always{
          ackCPU = (cmdCPU[28:31] == ID_CoP & ackCoP) | (cmdCPU[28:31] == ID_DataMem & ackDataMem) | (cmdCPU[28:31] == ID_Sensor & ackSensor) | (cmdCPU[28:31] == ID_Output & ackOutput); // "OR" all slaves ack signals here
          dataRdyCPU = dataRdyCoP | dataRdyDataMem | dataRdySensor | dataRdyOutput; // Only one slave can access the bus at any one time (only the slave which responds to the cmd)
          
          reqCoP = reqCPU;
          cmdCoP = (reqCoP) ? cmdCPU : 0;
          datainCoP = (reqCPU) ? dataoutCPU : 0;

          reqDataMem = reqCPU;
          cmdDataMem = (reqCPU) ? cmdCPU : 0;
          datainDataMem = (reqCPU) ? dataoutCPU : 0;
          
          reqSensor = reqCPU;
          cmdSensor = (reqCPU) ? cmdCPU : 0;
          waitSensor = waitCPU;
          
          reqOutput = reqCPU;
          cmdOutput = (reqCPU) ? cmdCPU : 0;
          datainOutput = (reqCPU) ? dataoutCPU : 0;
          waitOutput = waitCPU;
                    
          datainCPU = (dataRdyCoP) ? dataoutCoP :
                      (dataRdyDataMem) ? dataoutDataMem : 
                      (dataRdySensor) ? dataoutSensor : 
                      (dataRdyOutput) ? dataoutOutput :
                      0; // arbitrate here when multiple slaves
          waitDataMem = waitCPU;
          waitCoP = waitCPU;
          // TODO: waitCoP ?
          
          NotUsed1 = 0;
        }       
}

dp slavebusinterface(
          // Bus ports
          in bus_req : ns(1);
          in bus_cmd : ns(32);
          in bus_datain : ns(32);
          out bus_ack : ns(1);
          
          out bus_rdy : ns(1);
          out bus_dataout : ns(32);
          in bus_wait : ns(1);
          
          // Slave ports - data going in to the slave does not need a handshake. 
          in datain : ns(32); // data from main unit to interface
          in datainrdy : ns(1); // slave signals that data and cmd is rdy
          out dataout : ns(32); // data to slave
          out cmdout : ns(32); // cmd to slave
          out dataoutrdy : ns(1); // signal to slave telling that the data on dataout is rdy
          in targetID : ns(4); // specifies the ID used in the MSB of CMD, which is intended for this slave
          out stallSlave : ns(1) // true if the slaveinterface is currently busy and cannot receive data from the slave
          ){
          
          reg bus_reqr : ns(1);
          reg bus_waitr : ns(1);
          reg datainrdyr : ns(1);
          reg targetIDr : ns(4);
          reg bus_cmdr : ns(32);
          
          always{
             bus_reqr = bus_req;
             bus_waitr = bus_wait;
             datainrdyr = datainrdy;
             targetIDr = targetID;
             bus_cmdr = bus_cmd;
          }
          
          sfg externalData{
             bus_ack = 1;
             dataout = bus_datain;
             cmdout = bus_cmd;
             dataoutrdy = bus_cmd[28:31] == targetID; // is the cmd and data intended for this slave?
             
             bus_rdy = 0;
             bus_dataout = 0;
             stallSlave = 1;
          }
          
          sfg ackExternalData{
             bus_ack = 0;
             dataout = 0;
             cmdout = 0;
             dataoutrdy = 0;
             bus_rdy = 0;
             bus_dataout = 0;
             stallSlave = 1;
          }
          
          sfg internalData{
             bus_dataout = datain;
             bus_rdy = 1;
             
             bus_ack = 0;
             dataout = 0;
             cmdout = 0;
             dataoutrdy = 0;
             stallSlave = 1;
          }
          
          sfg ackInternalData{
             bus_rdy = 0;
             bus_dataout = 0;
             
             bus_ack = 0;
             dataout = 0;
             cmdout = 0;
             dataoutrdy = 0;
             stallSlave = 1;
          }
          
          sfg nothing{
             bus_ack = 0;
             dataout = 0;
             cmdout = 0;
             dataoutrdy = 0;
             bus_rdy = 0;
             bus_dataout = 0;
             stallSlave = 0;
          }
          
}

fsm slavebusinterface_cntrl(slavebusinterface){
   initial s0;
   state s1,s2,s3;
   
   // condition explanation: Only ack if the cmd is intended for this slave
   @s0 if (bus_reqr == 1 & bus_cmdr[28:31] == targetIDr) then (externalData) -> s1;
       else (nothing) -> s0;
   @s1 if (bus_reqr == 0) then (ackExternalData) ->s2;
       else (externalData) -> s1;
   @s2 if (datainrdyr == 1) then (internalData) -> s3;
       else (nothing) -> s2;
   @s3 if (bus_waitr == 1) then (ackInternalData) -> s0;
       else (internalData) -> s3;
   
}

dp slavebusinterface2 : slavebusinterface
dp slavebusinterface3 : slavebusinterface
dp slavebusinterface4 : slavebusinterface

dp masterbusinterface(
          // Bus ports
          out bus_req : ns(1); // master request the bus
          out bus_cmd : ns(32); // cmd to target unit
          out bus_dataout : ns(32); // data to target unit
          in bus_ack : ns(1); // ack from bus
                      
          in bus_rdy : ns(1); // rdy from bus
          in bus_datain : ns(32); // data targeted for the master
          out bus_wait : ns(1); // wait to bus
                    
          // Master ports - data going in to the master does not need a handshake. 
          in datain : ns(32); // data from main unit to interface
          in cmd : ns(32); // command from main unit to interface
          in datainrdy : ns(1); // master signals that data and cmd is rdy
          out dataout : ns(32); // data to master
          out dataoutrdy : ns(1) // signal to master telling that the data on dataout is rdy
          ){
          
//          $trace(bus_req, "traces/M_bus_req.seq");
//          $trace(bus_cmd, "traces/M_bus_cmd.seq");
//          $trace(bus_dataout, "traces/M_bus_dataout.seq");
//          $trace(bus_ack, "traces/M_bus_ack.seq");
//          $trace(bus_rdy, "traces/M_bus_rdy.seq");
//          $trace(bus_datain, "traces/M_bus_datain.seq");
//          $trace(bus_wait, "traces/M_bus_wait.seq");
          
//          $trace(datain, "traces/M_datain_int.seq");
//          $trace(cmd, "traces/M_cmd_int.seq");
//          $trace(datainrdy, "traces/M_datainrdy_int.seq");
//          $trace(dataout, "traces/M_dataout_int.seq");
//          $trace(dataoutrdy, "traces/M_dataoutrdy_int.seq");
          
          reg bus_ackr : ns(1);
          reg bus_rdyr : ns(1);
          reg datainrdyr : ns(1);
          reg cmdr : ns(32);
          reg datainr : ns(32);
                      
          always{
             bus_ackr = bus_ack;
             bus_rdyr = bus_rdy;
             datainrdyr = datainrdy;
             cmdr = cmd;
             datainr = datain;
          }
          
          sfg internalData{
             bus_req = 1;
             bus_cmd = cmd;
             bus_dataout = datain;
             
             bus_wait = 0;
             dataout = 0;
             dataoutrdy = 0;
          }
          
          sfg ackInternalData{
             bus_req = 0;
             bus_cmd = cmdr;
             bus_dataout = datainr;
             
             bus_wait = 0;
             dataout = 0;
             dataoutrdy = 0;
          }
          
          sfg externalData{
             bus_wait = 1;
             dataout = bus_datain;
             dataoutrdy = 1;
             
             bus_req = 0;
             bus_cmd = 0;
             bus_dataout = 0;
          }
          
          sfg ackExternalData{
              bus_wait = 0;
              dataout = 0;
              dataoutrdy = 0;
              
              bus_req = 0;
              bus_cmd = 0;
              bus_dataout = 0;
          }
                    
          sfg nothing{
             bus_req = 0;
             bus_cmd = cmdr;
             bus_dataout = datainr;
             
             bus_wait = 0;
             dataout = 0;
             dataoutrdy = 0;
          }
}

fsm masterbusinterface_cntrl(masterbusinterface){
   initial s0;
   state s1,s2,s3,s4;
   
   @s0 if (datainrdyr == 1) then (internalData) -> s1;
       else (nothing) -> s0; // do nothing
   @s1 if (bus_ackr == 1) then (ackInternalData) -> s3; // go to s3 in order to make sure the bus will not initiate a new communication due to the fact that the CPU is stalled at this particular bus-using instruction
       else (internalData) -> s1; // do nothing
   @s3 if (bus_rdyr == 1) then (externalData) -> s2;
       else (nothing) -> s3;
   @s2 (ackExternalData) -> s4; 
   @s4 (nothing) -> s0; // Wait one more cycle to synchronize with PC
}

dp bus_toplevel(
           // Master interface
           in M_datain : ns(32);
           in M_cmd : ns(32);
           in M_datainrdy : ns(1);
           out M_dataout : ns(32);
           out M_dataoutrdy : ns(1);
           //out stall_cpu : ns(1);

           // Slave interface (CoP)
           in COP_datain : ns(32);
           in COP_datainrdy : ns(1);
           out COP_dataout : ns(32);
           out COP_cmdout : ns(32);
           out COP_dataoutrdy : ns(1);
           out COP_stall : ns(1);
           
           // Slave interface (datamemory)
           in DM_datain : ns(32);
           in DM_datainrdy : ns(1);
           out DM_dataout : ns(32);
           out DM_cmdout : ns(32);
           out DM_dataoutrdy : ns(1);
           out DM_stall : ns(1);
           
           // Slave interface (Sensor)
           in SS_datain : ns(32);
           in SS_datainrdy : ns(1);
           out SS_dataout : ns(32); // data port not used in sensor
           out SS_cmdout : ns(32);
           out SS_dataoutrdy : ns(1);
           out SS_stall : ns(1);
           
           // Slave interface (output)
           in OP_datain : ns(32);
           in OP_datainrdy : ns(1);
           out OP_dataout : ns(32); // data port not used in sensor
           out OP_cmdout : ns(32);
           out OP_dataoutrdy : ns(1);
           out OP_stall : ns(1)
           ){
           
           sig reqCPU,reqCoP,reqDataMem,reqSensor,reqOutput,ackCPU,ackCoP,ackDataMem,ackSensor,ackOutput,dataRdyCPU,dataRdyCoP,dataRdyDataMem,dataRdySensor,dataRdyOutput,waitCPU,waitCoP,waitDataMem,waitSensor,waitOutput: ns(1);
           sig cmdCPU,cmdCoP,cmdDataMem,cmdSensor,cmdOutput,dataoutCPU,datainCoP,datainDataMem,datainSensor,datainOutput,datainCPU,dataoutCoP,dataoutDataMem,dataoutSensor,dataoutOutput : ns(32);
           reg ID_DataMem : ns(4);
           reg ID_Sensor : ns(4);
           reg ID_Output : ns(4);
           reg ID_CoP : ns(4);

           $trace(COP_datain, "traces/COP_datain.seq");
           $trace(COP_datainrdy, "traces/COP_datainrdy.seq");
           $trace(COP_dataout, "traces/COP_dataout.seq");
           $trace(COP_cmdout, "traces/COP_cmdout.seq");
           $trace(COP_dataoutrdy, "traces/COP_dataoutrdy.seq");
           
           $trace(DM_datain, "traces/DM_datain.seq");
           $trace(DM_datainrdy, "traces/DM_datainrdy.seq");
           $trace(DM_dataout, "traces/DM_dataout.seq");
           $trace(DM_cmdout, "traces/DM_cmdout.seq");
           $trace(DM_dataoutrdy, "traces/DM_dataoutrdy.seq");
           
           $trace(SS_datain, "traces/SS_datain.seq");
           $trace(SS_datainrdy, "traces/SS_datainrdy.seq");
           $trace(SS_dataout, "traces/SS_dataout.seq");
           $trace(SS_cmdout, "traces/SS_cmdout.seq");
           $trace(SS_dataoutrdy, "traces/SS_dataoutrdy.seq");
           
           $trace(OP_datain, "traces/OP_datain.seq");
           $trace(OP_datainrdy, "traces/OP_datainrdy.seq");
           $trace(OP_dataout, "traces/OP_dataout.seq");
           $trace(OP_cmdout, "traces/OP_cmdout.seq");
           $trace(OP_dataoutrdy, "traces/OP_dataoutrdy.seq");
           
           use bus(reqCPU,cmdCPU,dataoutCPU,ackCPU,dataRdyCPU,datainCPU,waitCPU, // master
                   reqCoP,cmdCoP,datainCoP,ackCoP,dataRdyCoP,dataoutCoP,waitCoP, // CoP (slave)
                   reqDataMem,cmdDataMem,datainDataMem,ackDataMem,dataRdyDataMem,dataoutDataMem,waitDataMem, // Data memory (slave)
                   reqSensor,cmdSensor,datainSensor,ackSensor,dataRdySensor,dataoutSensor,waitSensor,
                   reqOutput,cmdOutput,datainOutput,ackOutput,dataRdyOutput,dataoutOutput,waitOutput,// Sensor (slave)
                   ID_Sensor,ID_DataMem,ID_Output,ID_CoP); 
           
           use masterbusinterface(reqCPU,cmdCPU,dataoutCPU,ackCPU,dataRdyCPU,datainCPU,waitCPU, // Bus interface
                                  //CPUdatain,CPUcmd,CPUdatainrdy,CPUdataout,CPUdataoutrdy
                                  M_datain,M_cmd,M_datainrdy,M_dataout,M_dataoutrdy);

           use slavebusinterface(reqDataMem,cmdDataMem,datainDataMem,ackDataMem,dataRdyDataMem,dataoutDataMem,waitDataMem, // Bus interface (data memory)
                             //DMDatain,DMDatainrdy,DMDataout,DMCmdout,DMDataoutrdy,
                             DM_datain,DM_datainrdy,DM_dataout,DM_cmdout,DM_dataoutrdy,ID_DataMem,DM_stall);
                             
           use slavebusinterface2(reqSensor,cmdSensor,datainSensor,ackSensor,dataRdySensor,dataoutSensor,waitSensor, // Bus interface (Sensor)
                              //SensorDatain,SensorDatainrdy,NotUsed2,SensorCmdout,SensorDataoutrdy,
                              SS_datain,SS_datainrdy,SS_dataout,SS_cmdout,SS_dataoutrdy,ID_Sensor,SS_stall);
                              
           use slavebusinterface3(reqOutput,cmdOutput,datainOutput,ackOutput,dataRdyOutput,dataoutOutput,waitOutput, // Bus interface (data memory)
                              //OPDatain,OPDatainrdy,OPDataout,OPCmdout,OPDataoutrdy,
                              OP_datain,OP_datainrdy,OP_dataout,OP_cmdout,OP_dataoutrdy,ID_Output,OP_stall);

           use slavebusinterface4(reqCoP,cmdCoP,datainCoP,ackCoP,dataRdyCoP,dataoutCoP,waitCoP, // Bus interface (CoP)
                              //COPDatain,COPDatainrdy,COPDataout,COPCmdout,COPDataoutrdy,
                              COP_datain,COP_datainrdy,COP_dataout,COP_cmdout,COP_dataoutrdy,ID_CoP,COP_stall);
           
           always{
              ID_Sensor = 0x1;
              ID_DataMem = 0x2;
              ID_Output = 0x3;
              ID_CoP = 0x4;
           }
}

////////////////////////////
// Auxiliary units
////////////////////////////
ipblock datamem(in address : ns(12);
          in wr,rd   : ns(1);
          in idata   : ns(32);
          out odata : ns(32)){

  iptype "ram";
  ipparm "size=4096";
  ipparm "wl=32";
  ipparm "file=datamemory.txt"; // initializes content. File syntax needs to be "addr data "* (the last space can also be a linebreak. NB! Should the students do a manual loading of the RAM to simulate a "real" system or is it ok if they just use this parameter?
  //ipparm "file=sddb48hex2.ecg"; 
}

dp DataMem(
   in datain : ns(32);
   in cmd : ns(32);
   in datainrdy : ns(1);
   out dataout : ns(32);
   out dataoutrdy : ns(1);
   in stall : ns(1) // true if the slave is currently busy (with handshaking) and cannot receive new data.
   ){
   
   sig wr,rd : ns(1);
   sig address : ns(12);
   sig idata : ns(32);
   
   reg datainrdyr : ns(1);
   reg cmdr : ns(32);
   reg datainr : ns(32);
   reg dataoutr : ns(32);
   reg stallr : ns(1);
   
   use datamem(address,wr,rd,idata,dataout);
   
   $trace(address, "traces/DM_address.seq");
   $trace(wr, "traces/DM_wr.seq");
   $trace(rd, "traces/DM_rd.seq");
   $trace(idata, "traces/DM_idata.seq");
   
   always{
       stallr = stall;
       rd = cmdr[27] == 0;
       wr = cmdr[27] == 1;
       address = (cmdr[27] == 0) ? datainr : 0b00000 # cmdr[0:26]; // if Store Word instruction, use cmd[0:26] as address. If Load Word instruction use datain as address
       idata = (cmdr[27] == 0) ? 0 : datainr; // if store word use datain as data to be stored, if load word, just set idata to 0
       //$display($dec, "Cycle: ", $cycle);
   	   //$display($dec, "   address: ", address);
   }
   
   sfg captureData{
       dataoutrdy = 0; 
       datainrdyr = datainrdy;
       datainr = datain;
       cmdr = cmd;
   }
   
   sfg awaithandshake{
      dataoutrdy = 0;
   }
   
   sfg resetAndSignalRdy{
     dataoutrdy = 1;
     datainrdyr = 0;
   }
   
   sfg nothing{
       dataoutrdy = 0; 
   }
   
}

fsm DataMem_cntrl(DataMem){
   initial s0;
   state s1;
   
   @s0 if (datainrdyr == 1 & stallr == 0) then (resetAndSignalRdy) -> s0;
       else if (datainrdyr == 1 & stallr == 1) then (nothing) -> s1;
       else (captureData) -> s0;
   @s1 if (stallr == 0) then (resetAndSignalRdy) -> s0;
       else (awaithandshake) -> s1;
       
}

ipblock sensordata(in address : ns(5);
          in wr,rd   : ns(1);
          in idata   : ns(32);
          out odata : ns(32)){

  iptype "ram";
  ipparm "size=32";
  ipparm "wl=32";
  ipparm "file=sddb48hex.ecg"; // initializes content
  
}

dp Sensor(
   in datain : ns(32);
   in cmd : ns(32);
   in datainrdy : ns(1);
   out dataout : ns(32);
   out dataoutrdy : ns(1);
   in stall : ns(1) // true if the slave is currently busy (with handshaking) and cannot receive new data.
   ){
   
    sig address : ns(5);
    sig wr,rd : ns(1);
    sig idata,odata : ns(32);
    
    use sensordata(address,wr,rd,idata,odata);

   	reg c : ns(10);
   	reg reset : ns(1);
   	reg addr : ns(8);
   	reg LIMIT : ns(10); // How many cycles to wait before it "acquires" the next datapoint (simulated sampling rate)
   	reg stallr : ns(1);
   	reg datainrdyr : ns(1);
   	
   	$trace(odata, "traces/SS_data.seq");
   	$trace(c, "traces/SS_c.seq");
   	
   	always{
   		wr = 0;
   		idata = 0;
   		LIMIT = 9; // 0 means 1 cycles => Pick new point each cycle TODO: Set proper sampling rate
   		address = addr;
   		
   		dataout = odata;
   		//dataoutrdy = 0;
   		stallr = stall;
   		//$display($dec, "Cycle: ", $cycle);
   		//$display($dec, "   data: ", odata);
   		//$display($dec, "   address: ", address);
   	}
   	
   sfg captureData{  
       dataoutrdy = 0; 
       datainrdyr = datainrdy;
       // Removed all datain and cmd capturing registers, due to the fact that the sensor only has one function, which is to send data once requested
   }
   
   sfg awaithandshake{
      dataoutrdy = 0;
   }
   
   sfg resetAndSignalRdy{
     dataoutrdy = 1;
     datainrdyr = 0;
   }
   
   sfg nothing{
       dataoutrdy = 0; 
   }

	sfg count{
    	c = c + 1;
    	rd = 0;
	}
   	
   	sfg addressUpdate{
   	   addr = addr + 1;
   	   rd = 1;
   	   c = 0;
   	}

}

fsm sensor_cntrl(Sensor){
   initial s0;
   state s1;
       
   @s0 if (datainrdyr == 1 & stallr == 0 & c == LIMIT) then (addressUpdate,resetAndSignalRdy) -> s0;
       else if (datainrdyr == 1 & stallr == 0 &  c != LIMIT) then (count,resetAndSignalRdy) -> s0;
       else if (datainrdyr == 1 & stallr == 1 & c == LIMIT) then (addressUpdate,nothing) -> s1;
       else if (datainrdyr == 1 & stallr == 1 & c != LIMIT) then (count,nothing) -> s1;
       else if (datainrdyr == 0 & c == LIMIT) then (addressUpdate,captureData) -> s0;
       else (count,captureData) -> s0;
   @s1 if (stallr == 0 & c == LIMIT) then (addressUpdate,resetAndSignalRdy) -> s0;
       else if (stallr == 0 & c != LIMIT) then (count,resetAndSignalRdy) -> s0;
       else if (stallr == 1 & c == LIMIT) then (addressUpdate,awaithandshake) -> s1;
       else (count,awaithandshake) -> s1;
}

dp Output(
   in datain : ns(32);
   in cmd : ns(32);
   in datainrdy : ns(1);
   out dataout : ns(32);
   out dataoutrdy : ns(1);
   in stall : ns(1); // true if the slave is currently busy (with handshaking) and cannot receive new data.
   out FilterOut : tc(32)
   ){
   
   reg datainrdyr : ns(1);
   reg cmdr : ns(32);
   reg datainr : ns(32);
   reg dataoutr : ns(32);
   reg stallr : ns(1);
   reg count : ns(10);
   reg FilterOut_r : tc(32);
   
   $trace(FilterOut, "traces/FilterOut.seq");
   $trace(count, "traces/out_count.seq");
   
   always{
       stallr = stall;
       dataout = 0x123;
   }
   
   sfg captureData{
       dataoutrdy = 0; 
       datainrdyr = datainrdy;
       datainr = datain;
       cmdr = cmd;
       
       FilterOut = FilterOut_r;
   }
   
   sfg awaithandshake{
      dataoutrdy = 0;
      
      FilterOut = FilterOut_r;
   }
   
   sfg resetAndSignalRdy{
     dataoutrdy = 1;
     datainrdyr = 0;
   }
   
   sfg nothing{
       dataoutrdy = 0;
       
       FilterOut = FilterOut_r;
   }
   
   sfg setFilterOut{
      FilterOut = datainr;
      FilterOut_r = datainr;
      count = count + 1;
   }
   
}

fsm Output_cntrl(Output){
   initial s0;
   state s1;
   
   @s0 if (datainrdyr == 1 & stallr == 0) then (resetAndSignalRdy,setFilterOut) -> s0;
       else if (datainrdyr == 1 & stallr == 1) then (nothing) -> s1;
       else (captureData) -> s0;
   @s1 if (stallr == 0) then (resetAndSignalRdy,setFilterOut) -> s0;
       else (awaithandshake) -> s1;
       
}

////////////////////////////
// Co-Processor
////////////////////////////
dp CoPadd(
  in a,b  :tc(32);
  out r   :tc(32))
  {
    always{
      r = a + b;
    }
  }

dp CoPsub(
  in a,b  :tc(32);
  out r   :tc(32))
  {
    always{
      r = a - b;
    }
  }

dp CoPdiv32(
  in a  :tc(32);
  out r   :tc(32))
  {
    always{
      r = a>>5;
    }
  }

dp CoPregister(
  in sel   : ns(5); 
  in storeenable : ns(1);
  in new      : ns(32);
  in newsum   : ns(32);
  out old     : ns(32);
  out sum     : ns(32) 
  ){
  reg r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15,r16   : tc(32);
  reg r17,r18,r19,r20,r21,r22,r23,r24,r25,r26,r27,r28,r29,r30,r31,r32 : tc(32);
  always{
    old = (sel==0) ? r0 : 
      (sel==1) ? r1 :
      (sel==2) ? r2 :
      (sel==3) ? r3 :
      (sel==4) ? r4 : 
      (sel==5) ? r5 :
      (sel==6) ? r6 :
      (sel==7) ? r7 :
      (sel==8) ? r8 :
      (sel==9) ? r9 :
      (sel==10) ? r10 : 
      (sel==11) ? r11 :
      (sel==12) ? r12 :
      (sel==13) ? r13 :
      (sel==14) ? r14 :
      (sel==15) ? r15 :
      (sel==16) ? r16 : 
      (sel==17) ? r17 :
      (sel==18) ? r18 :
      (sel==19) ? r19 :
      (sel==20) ? r20 :
      (sel==21) ? r21 :
      (sel==22) ? r22 : 
      (sel==23) ? r23 :
      (sel==24) ? r24 :
      (sel==25) ? r25 :
      (sel==26) ? r26 :
      (sel==27) ? r27 :
      (sel==28) ? r28 : 
      (sel==29) ? r29 :
      (sel==30) ? r30 :
                   r31;

    sum = r32;
    r32 = storeenable ? newsum : r32;

    r0 = storeenable ? (sel==0) ? new : r0 : r0;
    r1 = storeenable ? (sel==1) ? new : r1 : r1;
    r2 = storeenable ? (sel==2) ? new : r2 : r2;
    r3 = storeenable ? (sel==3) ? new : r3 : r3;
    r4 = storeenable ? (sel==4) ? new : r4 : r4;
    r5 = storeenable ? (sel==5) ? new : r5 : r5;
    r6 = storeenable ? (sel==6) ? new : r6 : r6;
    r7 = storeenable ? (sel==7) ? new : r7 : r7;
    r8 = storeenable ? (sel==8) ? new : r8 : r8;
    r9 = storeenable ? (sel==9) ? new : r9 : r9;
    r10 = storeenable ? (sel==10) ? new : r10 : r10;
    r11 = storeenable ? (sel==11) ? new : r11 : r11;
    r12 = storeenable ? (sel==12) ? new : r12 : r12;
    r13 = storeenable ? (sel==13) ? new : r13 : r13;
    r14 = storeenable ? (sel==14) ? new : r14 : r14;
    r15 = storeenable ? (sel==15) ? new : r15 : r15;
    r16 = storeenable ? (sel==16) ? new : r16 : r16;
    r17 = storeenable ? (sel==17) ? new : r17 : r17;
    r18 = storeenable ? (sel==18) ? new : r18 : r18;
    r19 = storeenable ? (sel==19) ? new : r19 : r19;
    r20 = storeenable ? (sel==20) ? new : r20 : r20;
    r21 = storeenable ? (sel==21) ? new : r21 : r21;
    r22 = storeenable ? (sel==22) ? new : r22 : r22;
    r23 = storeenable ? (sel==23) ? new : r23 : r23;
    r24 = storeenable ? (sel==24) ? new : r24 : r24;
    r25 = storeenable ? (sel==25) ? new : r25 : r25;
    r26 = storeenable ? (sel==26) ? new : r26 : r26;
    r27 = storeenable ? (sel==27) ? new : r27 : r27;
    r28 = storeenable ? (sel==28) ? new : r28 : r28;
    r29 = storeenable ? (sel==29) ? new : r29 : r29;
    r30 = storeenable ? (sel==30) ? new : r30 : r30;
    r31 = storeenable ? (sel==31) ? new : r31 : r31;
  }
  $trace(r32, "traces/sum.seq");
  }

dp CoPC(  in inrdy        : ns(1);
        out pc_out    : ns(5))
  {
  reg PCr : ns(5);
  sig Val : ns(5);

  always{
    Val = PCr + inrdy;
    pc_out = (Val == 32) ? 0 : Val;
    PCr = pc_out;
  }
}

dp CoP(
       in datain      : ns(32);
       in cmd         : ns(32);
       in datainrdy   : ns(1);
       out dataout    : ns(32);
       out dataoutrdy : ns(1);
       in stall       : ns(1)
   ){
    sig pc_out      : ns(5);
    sig old     : ns(32);
    sig sum     : ns(32);
    sig sumsub  : ns(32);
    sig finalsum: ns(32);
    reg result  : ns(32);

    reg datainrdyr  : ns(1);
    reg cmdr        : ns(32);
    reg datainr     : ns(32);
    reg dataoutr    : ns(32);
    reg stallr      : ns(1);

    use CoPC(datainrdy,pc_out);
    use CoPregister(pc_out,datainrdy,datain,finalsum,old,sum);
    use CoPsub(sum,old,sumsub);
    use CoPadd(sumsub,datain,finalsum);
    use CoPdiv32(finalsum,result);

   always{
      stallr = stall;
      dataoutr = result;
      dataout = dataoutr;
      //$display($dec,"inrdy:",datainrdy,", outrdy:",dataoutrdy,", dout:",dataout);
   }   
   $trace(datainrdy, "traces/COPdatainrdy.seq");
   $trace(dataoutrdy, "traces/COPdataoutrdy.seq");
   $trace(stall, "traces/COPstall.seq");
   $trace(dataout, "traces/COPdataout.seq");
   $trace(datain, "traces/COPdatain.seq");
   $trace(old, "traces/COPold");
   $trace(cmd, "traces/COPcmd.seq");  
   $trace(dataoutr, "traces/COPdataoutr.seq");  
   $trace(pc_out, "traces/COPCout");

  sfg captureData{
    dataoutrdy = 0; 
    datainrdyr = datainrdy;
    datainr = datain;
    cmdr = cmd;
  }

  sfg awaithandshake{
    dataoutrdy = 0;
  }

  sfg resetAndSignalRdy{
    dataoutrdy = 1;
    datainrdyr = 0;
  }

  sfg nothing{
    dataoutrdy = 0; 
  }
}

fsm DataMem_cntrl(CoP){
   initial s0;
   state s1;
   
   @s0 if (datainrdyr == 1 & stallr == 0) then (resetAndSignalRdy) -> s0;
       else if (datainrdyr == 1 & stallr == 1) then (awaithandshake) -> s1;
       else (captureData) -> s0;
   @s1 if (stallr == 0) then (resetAndSignalRdy) -> s0;
       else (awaithandshake) -> s1;
       
}

////////////////////////////
// System connections
////////////////////////////
system CPUsystem{

   CPU(CPUdatain,CPUcmd,CPUdatainrdy,CPUdataout,CPUdataoutrdy);
   
   bus_toplevel(CPUdatain,CPUcmd,CPUdatainrdy,CPUdataout,CPUdataoutrdy, // master unit
           COPDatain,COPDatainrdy,COPDataout,COPCmdout,COPDataoutrdy,COPStall, // slave (CoP)
           DMDatain,DMDatainrdy,DMDataout,DMCmdout,DMDataoutrdy,DMStall, // slave (data memory)
           SensorDatain,SensorDatainrdy,SensorDataout,SensorCmdout,SensorDataoutrdy,SensorStall,  // slave (sensor)
           OPDatain,OPDatainrdy,OPDataout,OPCmdout,OPDataoutrdy,OPStall); // slave (Output)

   CoP(COPDataout,COPCmdout,COPDataoutrdy,COPDatain,COPDatainrdy,COPStall); // Co-Processor
   DataMem(DMDataout,DMCmdout,DMDataoutrdy,DMDatain,DMDatainrdy,DMStall); // Data Memory Unit
   Sensor(SensorDataout,SensorCmdout,SensorDataoutrdy,SensorDatain,SensorDatainrdy,SensorStall);
   Output(OPDataout,OPCmdout,OPDataoutrdy,OPDatain,OPDatainrdy,OPStall,FilterOut);
}